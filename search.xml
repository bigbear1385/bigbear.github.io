<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>新博客测试张雄</title>
    <url>/bigbear.github.io/2024/11/27/%E6%96%B0%E5%8D%9A%E5%AE%A2%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p>jkasdkljakljdasjdlasjdlajsdlajsdkj</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/bigbear.github.io/2024/11/27/glx_egl_gl%E6%8E%A5%E5%8F%A3%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="glx"><a href="#glx" class="headerlink" title="glx"></a>glx</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="一组用于管理OGL和X-windows集成的接口和函数"><a href="#一组用于管理OGL和X-windows集成的接口和函数" class="headerlink" title="一组用于管理OGL和X windows集成的接口和函数"></a>一组用于管理OGL和X windows集成的接口和函数</h3><h2 id="主要接口"><a href="#主要接口" class="headerlink" title="主要接口"></a>主要接口</h2><h3 id="glXChooseVisual"><a href="#glXChooseVisual" class="headerlink" title="glXChooseVisual"></a>glXChooseVisual</h3><h4 id="XVisualInfo-glXChooseVisual-Display-dpy-int-screen-int-attribList"><a href="#XVisualInfo-glXChooseVisual-Display-dpy-int-screen-int-attribList" class="headerlink" title="XVisualInfo* glXChooseVisual(Display *dpy, int screen, int *attribList);"></a>XVisualInfo* glXChooseVisual(Display *dpy, int screen, int *attribList);</h4><h4 id="根据给定属性列表选择合适的XVisualInfo"><a href="#根据给定属性列表选择合适的XVisualInfo" class="headerlink" title="根据给定属性列表选择合适的XVisualInfo"></a>根据给定属性列表选择合适的XVisualInfo</h4><h3 id="glXCreateContext"><a href="#glXCreateContext" class="headerlink" title="glXCreateContext"></a>glXCreateContext</h3><h4 id="GLXContext-glXCreateContext-Display-dpy-XVisualInfo-vis-GLXContext-shareList-Bool-direct"><a href="#GLXContext-glXCreateContext-Display-dpy-XVisualInfo-vis-GLXContext-shareList-Bool-direct" class="headerlink" title="GLXContext glXCreateContext(Display *dpy, XVisualInfo *vis, GLXContext shareList, Bool direct);"></a>GLXContext glXCreateContext(Display *dpy, XVisualInfo *vis, GLXContext shareList, Bool direct);</h4><h5 id="direct"><a href="#direct" class="headerlink" title="direct"></a>direct</h5><h6 id="是否使用直接渲染"><a href="#是否使用直接渲染" class="headerlink" title="是否使用直接渲染"></a>是否使用直接渲染</h6><h4 id="创建一个新的OGL上下文"><a href="#创建一个新的OGL上下文" class="headerlink" title="创建一个新的OGL上下文"></a>创建一个新的OGL上下文</h4><h3 id="glXCreateWindow"><a href="#glXCreateWindow" class="headerlink" title="glXCreateWindow"></a>glXCreateWindow</h3><h4 id="GLXDrawable-glXCreateWindow-Display-dpy-GLXFBConfig-config-Window-win-const-int-attrib-list"><a href="#GLXDrawable-glXCreateWindow-Display-dpy-GLXFBConfig-config-Window-win-const-int-attrib-list" class="headerlink" title="GLXDrawable glXCreateWindow(Display *dpy, GLXFBConfig config, Window win, const int *attrib_list);"></a>GLXDrawable glXCreateWindow(Display *dpy, GLXFBConfig config, Window win, const int *attrib_list);</h4><h4 id="创建一个GLX窗口，在窗口系统中与OGL结合使用的绘图表面，返回值为GLXDrawable"><a href="#创建一个GLX窗口，在窗口系统中与OGL结合使用的绘图表面，返回值为GLXDrawable" class="headerlink" title="创建一个GLX窗口，在窗口系统中与OGL结合使用的绘图表面，返回值为GLXDrawable"></a>创建一个GLX窗口，在窗口系统中与OGL结合使用的绘图表面，返回值为GLXDrawable</h4><h3 id="glXMakeCurrent"><a href="#glXMakeCurrent" class="headerlink" title="glXMakeCurrent"></a>glXMakeCurrent</h3><h4 id="Bool-glXMakeCurrent-Display-dpy-GLXDrawable-drawable-GLXContext-ctx"><a href="#Bool-glXMakeCurrent-Display-dpy-GLXDrawable-drawable-GLXContext-ctx" class="headerlink" title="Bool glXMakeCurrent(Display *dpy, GLXDrawable drawable, GLXContext ctx);"></a>Bool glXMakeCurrent(Display *dpy, GLXDrawable drawable, GLXContext ctx);</h4><h4 id="将OGL渲染上下文绑定到当前线程的执行的绘图Drawable"><a href="#将OGL渲染上下文绑定到当前线程的执行的绘图Drawable" class="headerlink" title="将OGL渲染上下文绑定到当前线程的执行的绘图Drawable"></a>将OGL渲染上下文绑定到当前线程的执行的绘图Drawable</h4><h4 id="glXMakeContextCurrent"><a href="#glXMakeContextCurrent" class="headerlink" title="glXMakeContextCurrent"></a>glXMakeContextCurrent</h4><h5 id="Bool-glXMakeContextCurrent-Display-dpy-GLXDrawable-draw-GLXDrawable-read-GLXContext-ctx"><a href="#Bool-glXMakeContextCurrent-Display-dpy-GLXDrawable-draw-GLXDrawable-read-GLXContext-ctx" class="headerlink" title="Bool glXMakeContextCurrent(Display *dpy, GLXDrawable draw, GLXDrawable read, GLXContext ctx);"></a>Bool glXMakeContextCurrent(Display *dpy, GLXDrawable draw, GLXDrawable read, GLXContext ctx);</h5><h5 id="扩展函数"><a href="#扩展函数" class="headerlink" title="扩展函数"></a>扩展函数</h5><h5 id="适合多线程，或者复杂渲染需求的应用程序"><a href="#适合多线程，或者复杂渲染需求的应用程序" class="headerlink" title="适合多线程，或者复杂渲染需求的应用程序"></a>适合多线程，或者复杂渲染需求的应用程序</h5><h5 id="将读写drawable分开设置，都能正确进行，也能设置为一样的"><a href="#将读写drawable分开设置，都能正确进行，也能设置为一样的" class="headerlink" title="将读写drawable分开设置，都能正确进行，也能设置为一样的"></a>将读写drawable分开设置，都能正确进行，也能设置为一样的</h5><h3 id="glXSwapBuffers"><a href="#glXSwapBuffers" class="headerlink" title="glXSwapBuffers"></a>glXSwapBuffers</h3><h4 id="void-glXSwapBuffers-Display-dpy-GLXDrawable-drawable"><a href="#void-glXSwapBuffers-Display-dpy-GLXDrawable-drawable" class="headerlink" title="void glXSwapBuffers(Display *dpy, GLXDrawable drawable);"></a>void glXSwapBuffers(Display *dpy, GLXDrawable drawable);</h4><h4 id="交换前后缓冲区，显示双缓冲模式下的渲染结果"><a href="#交换前后缓冲区，显示双缓冲模式下的渲染结果" class="headerlink" title="交换前后缓冲区，显示双缓冲模式下的渲染结果"></a>交换前后缓冲区，显示双缓冲模式下的渲染结果</h4><h3 id="glXDestroyContext"><a href="#glXDestroyContext" class="headerlink" title="glXDestroyContext"></a>glXDestroyContext</h3><h4 id="void-glXDestroyContext-Display-dpy-GLXContext-ctx"><a href="#void-glXDestroyContext-Display-dpy-GLXContext-ctx" class="headerlink" title="void glXDestroyContext(Display *dpy, GLXContext ctx);"></a>void glXDestroyContext(Display *dpy, GLXContext ctx);</h4><h4 id="销毁一个指定的上下文"><a href="#销毁一个指定的上下文" class="headerlink" title="销毁一个指定的上下文"></a>销毁一个指定的上下文</h4><h3 id="glXGetProcAddress"><a href="#glXGetProcAddress" class="headerlink" title="glXGetProcAddress"></a>glXGetProcAddress</h3><h4 id="void-glXGetProcAddress-const-GLubyte-procName"><a href="#void-glXGetProcAddress-const-GLubyte-procName" class="headerlink" title="void (*glXGetProcAddress(const GLubyte *procName))();"></a>void (*glXGetProcAddress(const GLubyte *procName))();</h4><h4 id="获取OGL或GLX扩展函数的地址"><a href="#获取OGL或GLX扩展函数的地址" class="headerlink" title="获取OGL或GLX扩展函数的地址"></a>获取OGL或GLX扩展函数的地址</h4><h3 id="glXQueryVersion"><a href="#glXQueryVersion" class="headerlink" title="glXQueryVersion"></a>glXQueryVersion</h3><h4 id="Bool-glXQueryVersion-Display-dpy-int-maj-int-min"><a href="#Bool-glXQueryVersion-Display-dpy-int-maj-int-min" class="headerlink" title="Bool glXQueryVersion(Display *dpy, int *maj, int *min);"></a>Bool glXQueryVersion(Display *dpy, int *maj, int *min);</h4><h4 id="查询GLX主次版本"><a href="#查询GLX主次版本" class="headerlink" title="查询GLX主次版本"></a>查询GLX主次版本</h4><h3 id="glXCreatePbuffer"><a href="#glXCreatePbuffer" class="headerlink" title="glXCreatePbuffer"></a>glXCreatePbuffer</h3><h4 id="GLXPbuffer-glXCreatePbuffer-Display-dpy-GLXFBConfig-config-const-int-attribList"><a href="#GLXPbuffer-glXCreatePbuffer-Display-dpy-GLXFBConfig-config-const-int-attribList" class="headerlink" title="GLXPbuffer glXCreatePbuffer(Display *dpy, GLXFBConfig config, const int *attribList);"></a>GLXPbuffer glXCreatePbuffer(Display *dpy, GLXFBConfig config, const int *attribList);</h4><h4 id="创建一个Pbuffer，Pixel-Buffer，离屏渲染"><a href="#创建一个Pbuffer，Pixel-Buffer，离屏渲染" class="headerlink" title="创建一个Pbuffer，Pixel Buffer，离屏渲染"></a>创建一个Pbuffer，Pixel Buffer，离屏渲染</h4><h3 id="glXQueryExtensionsString"><a href="#glXQueryExtensionsString" class="headerlink" title="glXQueryExtensionsString"></a>glXQueryExtensionsString</h3><h4 id="const-char-glXQueryExtensionsString-Display-dpy-int-screen"><a href="#const-char-glXQueryExtensionsString-Display-dpy-int-screen" class="headerlink" title="const char* glXQueryExtensionsString(Display *dpy, int screen);"></a>const char* glXQueryExtensionsString(Display *dpy, int screen);</h4><h4 id="获取glx扩展列表"><a href="#获取glx扩展列表" class="headerlink" title="获取glx扩展列表"></a>获取glx扩展列表</h4><h3 id="glXSwapIntervalEXT"><a href="#glXSwapIntervalEXT" class="headerlink" title="glXSwapIntervalEXT"></a>glXSwapIntervalEXT</h3><h4 id="void-glXSwapIntervalEXT-Display-dpy-GLXDrawable-drawable-int-interval"><a href="#void-glXSwapIntervalEXT-Display-dpy-GLXDrawable-drawable-int-interval" class="headerlink" title="void glXSwapIntervalEXT(Display *dpy, GLXDrawable drawable, int interval);"></a>void glXSwapIntervalEXT(Display *dpy, GLXDrawable drawable, int interval);</h4><h4 id="扩展函数-1"><a href="#扩展函数-1" class="headerlink" title="扩展函数"></a>扩展函数</h4><h5 id="控制垂直同步的交换间隔，设置交换缓冲区的频率，0关闭vvsync、1打开vsync，n每隔n次屏幕刷新交换缓冲区"><a href="#控制垂直同步的交换间隔，设置交换缓冲区的频率，0关闭vvsync、1打开vsync，n每隔n次屏幕刷新交换缓冲区" class="headerlink" title="控制垂直同步的交换间隔，设置交换缓冲区的频率，0关闭vvsync、1打开vsync，n每隔n次屏幕刷新交换缓冲区"></a>控制垂直同步的交换间隔，设置交换缓冲区的频率，0关闭vvsync、1打开vsync，n每隔n次屏幕刷新交换缓冲区</h5><h2 id="常见其他接口"><a href="#常见其他接口" class="headerlink" title="常见其他接口"></a>常见其他接口</h2><h3 id="glXQueryServerString"><a href="#glXQueryServerString" class="headerlink" title="glXQueryServerString"></a>glXQueryServerString</h3><h4 id="const-char-glXQueryServerString-Display-dpy-int-screen-int-name"><a href="#const-char-glXQueryServerString-Display-dpy-int-screen-int-name" class="headerlink" title="const char *glXQueryServerString(Display *dpy, int screen, int name);"></a>const char *glXQueryServerString(Display *dpy, int screen, int name);</h4><h4 id="查询GLX服务器相关的信息，包括Vendor、Version、Extensions"><a href="#查询GLX服务器相关的信息，包括Vendor、Version、Extensions" class="headerlink" title="查询GLX服务器相关的信息，包括Vendor、Version、Extensions"></a>查询GLX服务器相关的信息，包括Vendor、Version、Extensions</h4><h3 id="glXGetFBConfigs"><a href="#glXGetFBConfigs" class="headerlink" title="glXGetFBConfigs"></a>glXGetFBConfigs</h3><h4 id="GLXFBConfig-glXGetFBConfigs-Display-dpy-int-screen-int-nelements"><a href="#GLXFBConfig-glXGetFBConfigs-Display-dpy-int-screen-int-nelements" class="headerlink" title="GLXFBConfig* glXGetFBConfigs(Display *dpy, int screen, int *nelements);"></a>GLXFBConfig* glXGetFBConfigs(Display *dpy, int screen, int *nelements);</h4><h4 id="获取与特定显示和屏幕关联的帧缓冲配置，配置描述各种属性，颜色深度、深度缓冲区、模版缓冲区"><a href="#获取与特定显示和屏幕关联的帧缓冲配置，配置描述各种属性，颜色深度、深度缓冲区、模版缓冲区" class="headerlink" title="获取与特定显示和屏幕关联的帧缓冲配置，配置描述各种属性，颜色深度、深度缓冲区、模版缓冲区"></a>获取与特定显示和屏幕关联的帧缓冲配置，配置描述各种属性，颜色深度、深度缓冲区、模版缓冲区</h4><h3 id="glXGetVisualFromFBConfig"><a href="#glXGetVisualFromFBConfig" class="headerlink" title="glXGetVisualFromFBConfig"></a>glXGetVisualFromFBConfig</h3><h4 id="XVisualInfo-glXGetVisualFromFBConfig-Display-dpy-GLXFBConfig-config"><a href="#XVisualInfo-glXGetVisualFromFBConfig-Display-dpy-GLXFBConfig-config" class="headerlink" title="XVisualInfo* glXGetVisualFromFBConfig(Display *dpy, GLXFBConfig config);"></a>XVisualInfo* glXGetVisualFromFBConfig(Display *dpy, GLXFBConfig config);</h4><h4 id="从一个帧缓冲配置-glxfbconfig中获取与之关联的XVisualInfo，用于创建一个与FB兼容的窗口"><a href="#从一个帧缓冲配置-glxfbconfig中获取与之关联的XVisualInfo，用于创建一个与FB兼容的窗口" class="headerlink" title="从一个帧缓冲配置 glxfbconfig中获取与之关联的XVisualInfo，用于创建一个与FB兼容的窗口"></a>从一个帧缓冲配置 glxfbconfig中获取与之关联的XVisualInfo，用于创建一个与FB兼容的窗口</h4><h3 id="glXCreateContextAttribsARB"><a href="#glXCreateContextAttribsARB" class="headerlink" title="glXCreateContextAttribsARB"></a>glXCreateContextAttribsARB</h3><h4 id="GLXContext-glXCreateContextAttribsARB-Display-dpy-GLXFBConfig-config-GLXContext-share-context-Bool-direct-const-int-attrib-list"><a href="#GLXContext-glXCreateContextAttribsARB-Display-dpy-GLXFBConfig-config-GLXContext-share-context-Bool-direct-const-int-attrib-list" class="headerlink" title="GLXContext glXCreateContextAttribsARB(Display *dpy, GLXFBConfig config, GLXContext share_context, Bool direct, const int *attrib_list);"></a>GLXContext glXCreateContextAttribsARB(Display *dpy, GLXFBConfig config, GLXContext share_context, Bool direct, const int *attrib_list);</h4><h4 id="扩展函数，创建具有特定属性的OGL上下文，"><a href="#扩展函数，创建具有特定属性的OGL上下文，" class="headerlink" title="扩展函数，创建具有特定属性的OGL上下文，"></a>扩展函数，创建具有特定属性的OGL上下文，</h4><h3 id="glXQueryDrawable"><a href="#glXQueryDrawable" class="headerlink" title="glXQueryDrawable"></a>glXQueryDrawable</h3><h4 id="Bool-glXQueryDrawable-Display-dpy-GLXDrawable-drawable-int-attribute-unsigned-int-value"><a href="#Bool-glXQueryDrawable-Display-dpy-GLXDrawable-drawable-int-attribute-unsigned-int-value" class="headerlink" title="Bool glXQueryDrawable(Display *dpy, GLXDrawable drawable, int attribute, unsigned int *value);"></a>Bool glXQueryDrawable(Display *dpy, GLXDrawable drawable, int attribute, unsigned int *value);</h4><h4 id="查询glx窗口系统绘图表面的特性，比如高度，像素、宽度"><a href="#查询glx窗口系统绘图表面的特性，比如高度，像素、宽度" class="headerlink" title="查询glx窗口系统绘图表面的特性，比如高度，像素、宽度"></a>查询glx窗口系统绘图表面的特性，比如高度，像素、宽度</h4><h1 id="mesa-21-2-1-so产物"><a href="#mesa-21-2-1-so产物" class="headerlink" title="mesa 21.2.1 so产物"></a>mesa 21.2.1 so产物</h1><h2 id="libglapi-musa-so"><a href="#libglapi-musa-so" class="headerlink" title="libglapi_musa.so"></a>libglapi_musa.so</h2><h3 id="hardcode"><a href="#hardcode" class="headerlink" title="hardcode"></a>hardcode</h3><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p><img src="C:/Users/xiong.zhang/Documents/143.png" alt="143"></p>
<h2 id="libmusa-mesa-wsi-so"><a href="#libmusa-mesa-wsi-so" class="headerlink" title="libmusa_mesa_wsi.so"></a>libmusa_mesa_wsi.so</h2><h3 id="usr-lib-x86-64-linux-gnu-musa-libmusa-mesa-wsi-so"><a href="#usr-lib-x86-64-linux-gnu-musa-libmusa-mesa-wsi-so" class="headerlink" title="&#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;musa&#x2F;libmusa_mesa_wsi.so"></a>&#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;musa&#x2F;libmusa_mesa_wsi.so</h3><h3 id="是API和窗口系统的桥梁，提供底层窗口系统的通用接口，屏蔽X11、wayland、DRM之间的差异"><a href="#是API和窗口系统的桥梁，提供底层窗口系统的通用接口，屏蔽X11、wayland、DRM之间的差异" class="headerlink" title="是API和窗口系统的桥梁，提供底层窗口系统的通用接口，屏蔽X11、wayland、DRM之间的差异"></a>是API和窗口系统的桥梁，提供底层窗口系统的通用接口，屏蔽X11、wayland、DRM之间的差异</h3><h2 id="libgbm-so-1-0-0"><a href="#libgbm-so-1-0-0" class="headerlink" title="libgbm.so.1.0.0"></a>libgbm.so.1.0.0</h2><h2 id="libmusa-gbm-so-1-0-0"><a href="#libmusa-gbm-so-1-0-0" class="headerlink" title="libmusa_gbm.so.1.0.0."></a>libmusa_gbm.so.1.0.0.</h2><h2 id="libEGL-musa-so-0-0-0"><a href="#libEGL-musa-so-0-0-0" class="headerlink" title="libEGL_musa.so.0.0.0."></a>libEGL_musa.so.0.0.0.</h2><h3 id="usr-share-glvnd-egl-vendor-d-00-mtgpu-json中配置"><a href="#usr-share-glvnd-egl-vendor-d-00-mtgpu-json中配置" class="headerlink" title="usr&#x2F;share&#x2F;glvnd&#x2F;egl_vendor.d&#x2F;00_mtgpu.json中配置"></a>usr&#x2F;share&#x2F;glvnd&#x2F;egl_vendor.d&#x2F;00_mtgpu.json中配置</h3><h2 id="libGLX-musa-so-0-0-0"><a href="#libGLX-musa-so-0-0-0" class="headerlink" title="libGLX_musa.so.0.0.0."></a>libGLX_musa.so.0.0.0.</h2><h3 id="usr-share-X11-xorg-conf-d-10-mtgpu-conf"><a href="#usr-share-X11-xorg-conf-d-10-mtgpu-conf" class="headerlink" title="usr&#x2F;share&#x2F;X11&#x2F;xorg.conf.d&#x2F;10-mtgpu.conf"></a>usr&#x2F;share&#x2F;X11&#x2F;xorg.conf.d&#x2F;10-mtgpu.conf</h3><h3 id="GlxVendorLibrary-字段来配置GL库的名称或者路径"><a href="#GlxVendorLibrary-字段来配置GL库的名称或者路径" class="headerlink" title="GlxVendorLibrary 字段来配置GL库的名称或者路径"></a>GlxVendorLibrary 字段来配置GL库的名称或者路径</h3><h2 id="libmesa-dri-drivers-so"><a href="#libmesa-dri-drivers-so" class="headerlink" title="libmesa_dri_drivers.so."></a>libmesa_dri_drivers.so.</h2><h3 id="usr-lib-x86-64-linux-gnu-dri-musa-dri-so"><a href="#usr-lib-x86-64-linux-gnu-dri-musa-dri-so" class="headerlink" title="&#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;dri&#x2F;musa_dri.so"></a>&#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;dri&#x2F;musa_dri.so</h3><h2 id="libgallium-dri-so"><a href="#libgallium-dri-so" class="headerlink" title="libgallium_dri.so."></a>libgallium_dri.so.</h2><h3 id="usr-lib-x86-64-linux-gnu-dri-swrast-musa-dri-so"><a href="#usr-lib-x86-64-linux-gnu-dri-swrast-musa-dri-so" class="headerlink" title="&#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;dri&#x2F;swrast_musa_dri.so"></a>&#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;dri&#x2F;swrast_musa_dri.so</h3><h3 id="usr-lib-x86-64-linux-gnu-dri-kms-swrast-musa-dri-so"><a href="#usr-lib-x86-64-linux-gnu-dri-kms-swrast-musa-dri-so" class="headerlink" title="&#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;dri&#x2F;kms_swrast_musa_dri.so"></a>&#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;dri&#x2F;kms_swrast_musa_dri.so</h3><h1 id="DRI"><a href="#DRI" class="headerlink" title="DRI"></a>DRI</h1><h2 id="DRI1"><a href="#DRI1" class="headerlink" title="DRI1"></a>DRI1</h2><h3 id="子主题"><a href="#子主题" class="headerlink" title="子主题"></a>子主题</h3><h2 id="DRI2"><a href="#DRI2" class="headerlink" title="DRI2"></a>DRI2</h2><h3 id="DRI2Connect"><a href="#DRI2Connect" class="headerlink" title="DRI2Connect"></a>DRI2Connect</h3><h4 id="建立应用与DRI2的连接"><a href="#建立应用与DRI2的连接" class="headerlink" title="建立应用与DRI2的连接"></a>建立应用与DRI2的连接</h4><h4 id="DRI2Connect-Display-display-XID-window"><a href="#DRI2Connect-Display-display-XID-window" class="headerlink" title="DRI2Connect(Display * display, XID window,"></a>DRI2Connect(Display * display, XID window,</h4><pre><code>        char **driverName, char **deviceName);
</code></pre>
<h3 id="DRI2Authenticate"><a href="#DRI2Authenticate" class="headerlink" title="DRI2Authenticate"></a>DRI2Authenticate</h3><h4 id="验证客户端访问GPU的权限"><a href="#验证客户端访问GPU的权限" class="headerlink" title="验证客户端访问GPU的权限"></a>验证客户端访问GPU的权限</h4><h4 id="DRI2Authenticate-Display-display-XID-window-drm-magic-t-magic"><a href="#DRI2Authenticate-Display-display-XID-window-drm-magic-t-magic" class="headerlink" title="DRI2Authenticate(Display * display, XID window, drm_magic_t magic);"></a>DRI2Authenticate(Display * display, XID window, drm_magic_t magic);</h4><h3 id="DRI2CreateDrawable"><a href="#DRI2CreateDrawable" class="headerlink" title="DRI2CreateDrawable"></a>DRI2CreateDrawable</h3><h4 id="为X11窗口创建渲染目标"><a href="#为X11窗口创建渲染目标" class="headerlink" title="为X11窗口创建渲染目标"></a>为X11窗口创建渲染目标</h4><h4 id="DRI2CreateDrawable-Display-display-XID-drawable"><a href="#DRI2CreateDrawable-Display-display-XID-drawable" class="headerlink" title="DRI2CreateDrawable(Display * display, XID drawable);"></a>DRI2CreateDrawable(Display * display, XID drawable);</h4><h3 id="DRI2GetBuffers"><a href="#DRI2GetBuffers" class="headerlink" title="DRI2GetBuffers"></a>DRI2GetBuffers</h3><h4 id="DRI2GetBuffersWithFormat-Display-dpy-XID-drawable"><a href="#DRI2GetBuffersWithFormat-Display-dpy-XID-drawable" class="headerlink" title="DRI2GetBuffersWithFormat(Display * dpy, XID drawable,"></a>DRI2GetBuffersWithFormat(Display * dpy, XID drawable,</h4><pre><code>                     int *width, int *height,
                     unsigned int *attachments,
                     int count, int *outCount);
</code></pre>
<h4 id="DRI2GetBuffers-Display-dpy-XID-drawable"><a href="#DRI2GetBuffers-Display-dpy-XID-drawable" class="headerlink" title="DRI2GetBuffers(Display * dpy, XID drawable,"></a>DRI2GetBuffers(Display * dpy, XID drawable,</h4><pre><code>           int *width, int *height,
           unsigned int *attachments, int count,
           int *outCount);
</code></pre>
<h4 id="分配或者获取渲染缓冲区"><a href="#分配或者获取渲染缓冲区" class="headerlink" title="分配或者获取渲染缓冲区"></a>分配或者获取渲染缓冲区</h4><h3 id="DRI2CopyRegion"><a href="#DRI2CopyRegion" class="headerlink" title="DRI2CopyRegion"></a>DRI2CopyRegion</h3><h4 id="复制缓冲区的特定区域"><a href="#复制缓冲区的特定区域" class="headerlink" title="复制缓冲区的特定区域"></a>复制缓冲区的特定区域</h4><h4 id="DRI2CopyRegion-Display-dpy-XID-drawable"><a href="#DRI2CopyRegion-Display-dpy-XID-drawable" class="headerlink" title="DRI2CopyRegion(Display * dpy, XID drawable,"></a>DRI2CopyRegion(Display * dpy, XID drawable,</h4><pre><code>           XserverRegion region,
           CARD32 dest, CARD32 src);
</code></pre>
<h2 id="DRI3"><a href="#DRI3" class="headerlink" title="DRI3"></a>DRI3</h2><h3 id="DRI3Open"><a href="#DRI3Open" class="headerlink" title="DRI3Open"></a>DRI3Open</h3><h4 id="打开一个设备文件访问GPU"><a href="#打开一个设备文件访问GPU" class="headerlink" title="打开一个设备文件访问GPU"></a>打开一个设备文件访问GPU</h4><h3 id="DRI3PixmapFromBuffer"><a href="#DRI3PixmapFromBuffer" class="headerlink" title="DRI3PixmapFromBuffer"></a>DRI3PixmapFromBuffer</h3><h4 id="从Client创建的Buffer生成一个Pixmap"><a href="#从Client创建的Buffer生成一个Pixmap" class="headerlink" title="从Client创建的Buffer生成一个Pixmap"></a>从Client创建的Buffer生成一个Pixmap</h4><h3 id="DRI3CreateFence"><a href="#DRI3CreateFence" class="headerlink" title="DRI3CreateFence"></a>DRI3CreateFence</h3><h4 id="创建同步用的fence"><a href="#创建同步用的fence" class="headerlink" title="创建同步用的fence"></a>创建同步用的fence</h4><h3 id="DRI3BufferFromPixmap"><a href="#DRI3BufferFromPixmap" class="headerlink" title="DRI3BufferFromPixmap"></a>DRI3BufferFromPixmap</h3><h4 id="从Pixmap获取缓冲对象"><a href="#从Pixmap获取缓冲对象" class="headerlink" title="从Pixmap获取缓冲对象"></a>从Pixmap获取缓冲对象</h4><h3 id="子主题-1"><a href="#子主题-1" class="headerlink" title="子主题"></a>子主题</h3><h1 id="Xlib"><a href="#Xlib" class="headerlink" title="Xlib"></a>Xlib</h1><h2 id="常见接口"><a href="#常见接口" class="headerlink" title="常见接口"></a>常见接口</h2><h3 id="XOpenDisplay"><a href="#XOpenDisplay" class="headerlink" title="XOpenDisplay"></a>XOpenDisplay</h3><h4 id="打开与X-Server的链接"><a href="#打开与X-Server的链接" class="headerlink" title="打开与X Server的链接"></a>打开与X Server的链接</h4><h4 id="Display-XOpenDisplay-const-char-display-name"><a href="#Display-XOpenDisplay-const-char-display-name" class="headerlink" title="Display *XOpenDisplay(const char *display_name);"></a>Display *XOpenDisplay(const char *display_name);</h4><h3 id="DefaultScreen"><a href="#DefaultScreen" class="headerlink" title="DefaultScreen"></a>DefaultScreen</h3><h4 id="int-DefaultScreen-Display-display"><a href="#int-DefaultScreen-Display-display" class="headerlink" title="int DefaultScreen(Display *display);"></a>int DefaultScreen(Display *display);</h4><h4 id="获取X11显示连接默认屏幕变好的函数"><a href="#获取X11显示连接默认屏幕变好的函数" class="headerlink" title="获取X11显示连接默认屏幕变好的函数"></a>获取X11显示连接默认屏幕变好的函数</h4><h3 id="display和Screen关系"><a href="#display和Screen关系" class="headerlink" title="display和Screen关系"></a>display和Screen关系</h3><h4 id="允许一个display连接到多个Screen"><a href="#允许一个display连接到多个Screen" class="headerlink" title="允许一个display连接到多个Screen"></a>允许一个display连接到多个Screen</h4><h4 id="一个Screen表示一个物理显示设备"><a href="#一个Screen表示一个物理显示设备" class="headerlink" title="一个Screen表示一个物理显示设备"></a>一个Screen表示一个物理显示设备</h4><h3 id="XCreateWindow"><a href="#XCreateWindow" class="headerlink" title="XCreateWindow"></a>XCreateWindow</h3><h4 id="Window-XCreateWindow"><a href="#Window-XCreateWindow" class="headerlink" title="Window XCreateWindow("></a>Window XCreateWindow(</h4><h5 id="Display-display"><a href="#Display-display" class="headerlink" title="Display *display,"></a>Display *display,</h5><h5 id="Window-parent"><a href="#Window-parent" class="headerlink" title="Window parent,"></a>Window parent,</h5><h5 id="int-x-int-y"><a href="#int-x-int-y" class="headerlink" title="int x, int y,"></a>int x, int y,</h5><h5 id="unsigned-int-width-unsigned-int-height"><a href="#unsigned-int-width-unsigned-int-height" class="headerlink" title="unsigned int width, unsigned int height,"></a>unsigned int width, unsigned int height,</h5><h5 id="unsigned-int-border-width"><a href="#unsigned-int-border-width" class="headerlink" title="unsigned int border_width,"></a>unsigned int border_width,</h5><h5 id="int-depth"><a href="#int-depth" class="headerlink" title="int depth,"></a>int depth,</h5><h5 id="unsigned-int-class"><a href="#unsigned-int-class" class="headerlink" title="unsigned int class,"></a>unsigned int class,</h5><h5 id="Visual-visual"><a href="#Visual-visual" class="headerlink" title="Visual *visual,"></a>Visual *visual,</h5><h5 id="unsigned-long-valuemask"><a href="#unsigned-long-valuemask" class="headerlink" title="unsigned long valuemask,"></a>unsigned long valuemask,</h5><h5 id="XSetWindowAttributes-attributes"><a href="#XSetWindowAttributes-attributes" class="headerlink" title="XSetWindowAttributes *attributes"></a>XSetWindowAttributes *attributes</h5><h4 id="创建窗口，允许设置窗口位置，大小边框、背景色等属性"><a href="#创建窗口，允许设置窗口位置，大小边框、背景色等属性" class="headerlink" title="创建窗口，允许设置窗口位置，大小边框、背景色等属性"></a>创建窗口，允许设置窗口位置，大小边框、背景色等属性</h4><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><h2 id="主题-1"><a href="#主题-1" class="headerlink" title="主题"></a>主题</h2><h1 id="gl"><a href="#gl" class="headerlink" title="gl"></a>gl</h1><h2 id="glGetIntegerv"><a href="#glGetIntegerv" class="headerlink" title="glGetIntegerv"></a>glGetIntegerv</h2><h3 id="void-glGetIntegerv-GLenum-pname-GLint-data"><a href="#void-glGetIntegerv-GLenum-pname-GLint-data" class="headerlink" title="void glGetIntegerv(GLenum pname, GLint *data);"></a>void glGetIntegerv(GLenum pname, GLint *data);</h3><h3 id="获取OGL状态变量的整数值"><a href="#获取OGL状态变量的整数值" class="headerlink" title="获取OGL状态变量的整数值"></a>获取OGL状态变量的整数值</h3><h4 id="GL-VIEWPORT"><a href="#GL-VIEWPORT" class="headerlink" title="GL_VIEWPORT"></a>GL_VIEWPORT</h4><h5 id="视口尺寸"><a href="#视口尺寸" class="headerlink" title="视口尺寸"></a>视口尺寸</h5><h4 id="GL-MAX-TEXTURE-SIZE"><a href="#GL-MAX-TEXTURE-SIZE" class="headerlink" title="GL_MAX_TEXTURE_SIZE"></a>GL_MAX_TEXTURE_SIZE</h4><h5 id="最大纹理尺寸"><a href="#最大纹理尺寸" class="headerlink" title="最大纹理尺寸"></a>最大纹理尺寸</h5><h4 id="GL-ACTIVE-TEXTURE"><a href="#GL-ACTIVE-TEXTURE" class="headerlink" title="GL_ACTIVE_TEXTURE"></a>GL_ACTIVE_TEXTURE</h4><h4 id="GL-CURRENT-PROGRAM"><a href="#GL-CURRENT-PROGRAM" class="headerlink" title="GL_CURRENT_PROGRAM"></a>GL_CURRENT_PROGRAM</h4><h4 id="GL-ARRAY-BUFFER-BINDING"><a href="#GL-ARRAY-BUFFER-BINDING" class="headerlink" title="GL_ARRAY_BUFFER_BINDING"></a>GL_ARRAY_BUFFER_BINDING</h4><h4 id="GL-ELEMENT-ARRAY-BUFFER-BINDING"><a href="#GL-ELEMENT-ARRAY-BUFFER-BINDING" class="headerlink" title="GL_ELEMENT_ARRAY_BUFFER_BINDING"></a>GL_ELEMENT_ARRAY_BUFFER_BINDING</h4><h4 id="GL-FRAMEBUFFER-BINDING"><a href="#GL-FRAMEBUFFER-BINDING" class="headerlink" title="GL_FRAMEBUFFER_BINDING"></a>GL_FRAMEBUFFER_BINDING</h4><h4 id="GL-NUM-EXTENSIONS"><a href="#GL-NUM-EXTENSIONS" class="headerlink" title="GL_NUM_EXTENSIONS"></a>GL_NUM_EXTENSIONS</h4><h5 id="支持的扩展数量"><a href="#支持的扩展数量" class="headerlink" title="支持的扩展数量"></a>支持的扩展数量</h5><h2 id="glClearColor"><a href="#glClearColor" class="headerlink" title="glClearColor"></a>glClearColor</h2><h3 id="void-glClearColor-GLfloat-red-GLfloat-green-GLfloat-blue-GLfloat-alpha"><a href="#void-glClearColor-GLfloat-red-GLfloat-green-GLfloat-blue-GLfloat-alpha" class="headerlink" title="void glClearColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);"></a>void glClearColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);</h3><h3 id="设置清除的颜色值"><a href="#设置清除的颜色值" class="headerlink" title="设置清除的颜色值"></a>设置清除的颜色值</h3><h2 id="glClear"><a href="#glClear" class="headerlink" title="glClear"></a>glClear</h2><h3 id="void-glClear-GLbitfield-mask"><a href="#void-glClear-GLbitfield-mask" class="headerlink" title="void glClear(GLbitfield mask);"></a>void glClear(GLbitfield mask);</h3><h3 id="清除缓冲区的数据"><a href="#清除缓冲区的数据" class="headerlink" title="清除缓冲区的数据"></a>清除缓冲区的数据</h3><h2 id="glViewport"><a href="#glViewport" class="headerlink" title="glViewport"></a>glViewport</h2><h3 id="设置视口"><a href="#设置视口" class="headerlink" title="设置视口"></a>设置视口</h3><h2 id="glScissor"><a href="#glScissor" class="headerlink" title="glScissor"></a>glScissor</h2><h3 id="设定矩形裁剪区域"><a href="#设定矩形裁剪区域" class="headerlink" title="设定矩形裁剪区域"></a>设定矩形裁剪区域</h3><h2 id="glShaderSource"><a href="#glShaderSource" class="headerlink" title="glShaderSource"></a>glShaderSource</h2><h3 id="void-glShaderSource-GLuint-shader-GLsizei-count-const-GLchar-conststring-const-GLint-length"><a href="#void-glShaderSource-GLuint-shader-GLsizei-count-const-GLchar-conststring-const-GLint-length" class="headerlink" title="void glShaderSource(GLuint shader, GLsizei count, const GLchar conststring, const GLint *length);"></a>void glShaderSource(GLuint shader, GLsizei count, const GLchar <em>const</em>string, const GLint *length);</h3><h3 id="着色器对象通常是顶点着色器或片段着色器等，用于在-GPU-上进行图形处理。这个函数是着色器编译和链接流程的一部分。"><a href="#着色器对象通常是顶点着色器或片段着色器等，用于在-GPU-上进行图形处理。这个函数是着色器编译和链接流程的一部分。" class="headerlink" title="着色器对象通常是顶点着色器或片段着色器等，用于在 GPU 上进行图形处理。这个函数是着色器编译和链接流程的一部分。"></a>着色器对象通常是顶点着色器或片段着色器等，用于在 GPU 上进行图形处理。这个函数是着色器编译和链接流程的一部分。</h3><h2 id="glBindBuffer"><a href="#glBindBuffer" class="headerlink" title="glBindBuffer"></a>glBindBuffer</h2><h3 id="glBindBuffer-target-GL-SHADER-STORAGE-BUFFER-buffer-1"><a href="#glBindBuffer-target-GL-SHADER-STORAGE-BUFFER-buffer-1" class="headerlink" title="glBindBuffer(target &#x3D; GL_SHADER_STORAGE_BUFFER, buffer &#x3D; 1);"></a>glBindBuffer(target &#x3D; GL_SHADER_STORAGE_BUFFER, buffer &#x3D; 1);</h3><h3 id="Shader-Storage-Buffer-Object-SSBO"><a href="#Shader-Storage-Buffer-Object-SSBO" class="headerlink" title="Shader Storage Buffer Object (SSBO)"></a>Shader Storage Buffer Object (SSBO)</h3><h4 id="操作一个着色器存储缓冲区对象，允许着色器程序写大块数据"><a href="#操作一个着色器存储缓冲区对象，允许着色器程序写大块数据" class="headerlink" title="操作一个着色器存储缓冲区对象，允许着色器程序写大块数据"></a>操作一个着色器存储缓冲区对象，允许着色器程序写大块数据</h4><h2 id="glMapBufferRange"><a href="#glMapBufferRange" class="headerlink" title="glMapBufferRange"></a>glMapBufferRange</h2><h3 id="void-glMapBufferRange-GLenum-target-GLintptr-offset-GLsizeiptr-length-GLbitfield-access"><a href="#void-glMapBufferRange-GLenum-target-GLintptr-offset-GLsizeiptr-length-GLbitfield-access" class="headerlink" title="void* glMapBufferRange(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access);"></a>void* glMapBufferRange(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access);</h3><h3 id="用于映射缓冲区对象的一部分内存到应用程序的地址空间的函数"><a href="#用于映射缓冲区对象的一部分内存到应用程序的地址空间的函数" class="headerlink" title="用于映射缓冲区对象的一部分内存到应用程序的地址空间的函数"></a>用于映射缓冲区对象的一部分内存到应用程序的地址空间的函数</h3><h3 id="返回一个指向缓冲区内存的指针"><a href="#返回一个指向缓冲区内存的指针" class="headerlink" title="返回一个指向缓冲区内存的指针"></a>返回一个指向缓冲区内存的指针</h3><h2 id="纹理操作"><a href="#纹理操作" class="headerlink" title="纹理操作"></a>纹理操作</h2><h3 id="申请纹理对象"><a href="#申请纹理对象" class="headerlink" title="申请纹理对象"></a>申请纹理对象</h3><h4 id="void-glGenTextures-GLsizei-n-GLuint-textTures"><a href="#void-glGenTextures-GLsizei-n-GLuint-textTures" class="headerlink" title="void glGenTextures(GLsizei n,GLuint * textTures);"></a>void glGenTextures(GLsizei n,GLuint * textTures);</h4><h3 id="绑定纹理状态"><a href="#绑定纹理状态" class="headerlink" title="绑定纹理状态"></a>绑定纹理状态</h3><h4 id="void-glBindTexture-GLenum-target-GLunit-texture"><a href="#void-glBindTexture-GLenum-target-GLunit-texture" class="headerlink" title="void glBindTexture(GLenum target,GLunit texture);"></a>void glBindTexture(GLenum target,GLunit texture);</h4><h4 id="target"><a href="#target" class="headerlink" title="target"></a>target</h4><h5 id="GL-TEXTURE-1D"><a href="#GL-TEXTURE-1D" class="headerlink" title="GL_TEXTURE_1D"></a>GL_TEXTURE_1D</h5><h5 id="GL-TEXTURE-2D"><a href="#GL-TEXTURE-2D" class="headerlink" title="GL_TEXTURE_2D"></a>GL_TEXTURE_2D</h5><h5 id="GL-TEXTURE-3D"><a href="#GL-TEXTURE-3D" class="headerlink" title="GL_TEXTURE_3D"></a>GL_TEXTURE_3D</h5><h3 id="设置纹理参数"><a href="#设置纹理参数" class="headerlink" title="设置纹理参数"></a>设置纹理参数</h3><h4 id="glTexParameteri-GLenum-target-GLenum-pname-GLint-param"><a href="#glTexParameteri-GLenum-target-GLenum-pname-GLint-param" class="headerlink" title="glTexParameteri(GLenum target,GLenum pname,GLint param);"></a>glTexParameteri(GLenum target,GLenum pname,GLint param);</h4><h4 id="参数类型有float和i"><a href="#参数类型有float和i" class="headerlink" title="参数类型有float和i"></a>参数类型有float和i</h4><h4 id="主要参数"><a href="#主要参数" class="headerlink" title="主要参数"></a>主要参数</h4><h5 id="设置过滤方式"><a href="#设置过滤方式" class="headerlink" title="设置过滤方式"></a>设置过滤方式</h5><h6 id="线性过滤和临近过滤，可以针对放大和缩小有两种过滤方式"><a href="#线性过滤和临近过滤，可以针对放大和缩小有两种过滤方式" class="headerlink" title="线性过滤和临近过滤，可以针对放大和缩小有两种过滤方式"></a>线性过滤和临近过滤，可以针对放大和缩小有两种过滤方式</h6><ul>
<li>glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_NEAREST);&#x2F;&#x2F;纹理放大时,使⽤线性过滤</li>
</ul>
<p>glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_NEAREST);&#x2F;&#x2F;纹理缩小时,使⽤邻近过滤</p>
<ul>
<li>glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);&#x2F;&#x2F;纹理放大时,使用线性过滤</li>
</ul>
<p> glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);&#x2F;&#x2F;纹理缩⼩时,使用邻近过滤</p>
<h5 id="设置环绕方式"><a href="#设置环绕方式" class="headerlink" title="设置环绕方式"></a>设置环绕方式</h5><h6 id="设置纹理的环绕方式，GL-REPEAT"><a href="#设置纹理的环绕方式，GL-REPEAT" class="headerlink" title="设置纹理的环绕方式，GL_REPEAT\"></a>设置纹理的环绕方式，GL_REPEAT\</h6><ul>
<li>glTexParameteri(target &#x3D; GL_TEXTURE_2D, pname &#x3D; GL_TEXTURE_WRAP_S, param &#x3D; GL_REPEAT)<br>glTexParameteri(target &#x3D; GL_TEXTURE_2D, pname &#x3D; GL_TEXTURE_WRAP_T, param &#x3D; GL_REPEAT)</li>
</ul>
<h3 id="改变和恢复像素存储方式"><a href="#改变和恢复像素存储方式" class="headerlink" title="改变和恢复像素存储方式"></a>改变和恢复像素存储方式</h3><h4 id="void-glPixelStorei-GLenum-pname-GLint-param"><a href="#void-glPixelStorei-GLenum-pname-GLint-param" class="headerlink" title="void glPixelStorei(GLenum pname, GLint param);"></a>void glPixelStorei(GLenum pname, GLint param);</h4><p>void glPixelStoref(GLenum pname, GLfloat param);</p>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><h5 id="像素的存储方式"><a href="#像素的存储方式" class="headerlink" title="像素的存储方式"></a>像素的存储方式</h5><h5 id="单位"><a href="#单位" class="headerlink" title="单位"></a>单位</h5><h3 id="读写颜色缓冲区内容"><a href="#读写颜色缓冲区内容" class="headerlink" title="读写颜色缓冲区内容"></a>读写颜色缓冲区内容</h3><h4 id="void-glReadPixels-GLint-x-GLint-y-GLSizei-width-GLSizei"><a href="#void-glReadPixels-GLint-x-GLint-y-GLSizei-width-GLSizei" class="headerlink" title="void glReadPixels(GLint x,GLint y,GLSizei width,GLSizei"></a>void glReadPixels(GLint x,GLint y,GLSizei width,GLSizei</h4><p>height, GLenum format, GLenum type,const void * pixels);</p>
<p>void glReadBuffer (GLenum mode)	&#x2F;&#x2F;指定读取的缓存	</p>
<p>glWriteBuffer(Glenum mode);&#x2F;&#x2F;	指定写⼊入的缓存</p>
<h3 id="load-纹理"><a href="#load-纹理" class="headerlink" title="load 纹理"></a>load 纹理</h3><h4 id="void-glTexImage1D-GLenum-target-GLint-level-GLint"><a href="#void-glTexImage1D-GLenum-target-GLint-level-GLint" class="headerlink" title="void glTexImage1D(GLenum target,GLint level,GLint"></a>void glTexImage1D(GLenum target,GLint level,GLint</h4><pre><code> internalformat,GLsizei width,GLint border,GLenum
 format,GLenum type,void *data);
 
</code></pre>
<p>void glTexImage2D(GLenum target,GLint level,GLint<br>     internalformat,GLsizei width,GLsizei height,GLint<br>     border,GLenum format,GLenum type,void * data);</p>
<p>void glTexImage3D(GLenum target,GLint level,GLint internalformat,GLSizei width,GLsizei height,GLsizei depth,GLint border,GLenum format,GLenum type,void *data);</p>
<h4 id="level"><a href="#level" class="headerlink" title="level"></a>level</h4><h5 id="指定加载mip贴图层次，一般设置为0"><a href="#指定加载mip贴图层次，一般设置为0" class="headerlink" title="指定加载mip贴图层次，一般设置为0"></a>指定加载mip贴图层次，一般设置为0</h5><h3 id="更新纹理"><a href="#更新纹理" class="headerlink" title="更新纹理"></a>更新纹理</h3><h4 id="void-glTexSubImage1D-GLenum-target-GLint-level-GLint-xOffset-GLsizei-width-GLenum"><a href="#void-glTexSubImage1D-GLenum-target-GLint-level-GLint-xOffset-GLsizei-width-GLenum" class="headerlink" title="void glTexSubImage1D(GLenum target,GLint level,GLint xOffset,GLsizei width,GLenum"></a>void glTexSubImage1D(GLenum target,GLint level,GLint xOffset,GLsizei width,GLenum</h4><pre><code>format,GLenum type,const GLvoid *data);
</code></pre>
<p>void glTexSubImage2D(GLenum target,GLint level,GLint xOffset,GLint yOffset,GLsizei<br>    width,GLsizei height,GLenum format,GLenum type,const GLvoid *data);</p>
<p>void glTexSubImage3D(GLenum target,GLint level,GLint xOffset,GLint yOffset,GLint<br>    zOffset,GLsizei width,GLsizei height,GLsizei depth,Glenum type,const GLvoid * data);</p>
<h4 id="子主题-2"><a href="#子主题-2" class="headerlink" title="子主题"></a>子主题</h4><h1 id="egl"><a href="#egl" class="headerlink" title="egl"></a>egl</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h4 id="渲染API和原生窗口系统之间的桥梁"><a href="#渲染API和原生窗口系统之间的桥梁" class="headerlink" title="渲染API和原生窗口系统之间的桥梁"></a>渲染API和原生窗口系统之间的桥梁</h4><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><h4 id="独立的api"><a href="#独立的api" class="headerlink" title="独立的api"></a>独立的api</h4><h4 id="主要作用"><a href="#主要作用" class="headerlink" title="主要作用"></a>主要作用</h4><h5 id="创建ctx"><a href="#创建ctx" class="headerlink" title="创建ctx"></a>创建ctx</h5><h5 id="绘制目标surface"><a href="#绘制目标surface" class="headerlink" title="绘制目标surface"></a>绘制目标surface</h5><h5 id="配置Framebuffer属性"><a href="#配置Framebuffer属性" class="headerlink" title="配置Framebuffer属性"></a>配置Framebuffer属性</h5><h5 id="Swap提交绘制结果"><a href="#Swap提交绘制结果" class="headerlink" title="Swap提交绘制结果"></a>Swap提交绘制结果</h5><h4 id="主要机制"><a href="#主要机制" class="headerlink" title="主要机制"></a>主要机制</h4><h5 id="与原生窗口通信"><a href="#与原生窗口通信" class="headerlink" title="与原生窗口通信"></a>与原生窗口通信</h5><h5 id="查询绘制surface的可用类型和配置"><a href="#查询绘制surface的可用类型和配置" class="headerlink" title="查询绘制surface的可用类型和配置"></a>查询绘制surface的可用类型和配置</h5><h5 id="创建绘制surface"><a href="#创建绘制surface" class="headerlink" title="创建绘制surface"></a>创建绘制surface</h5><h5 id="管理纹理贴图等渲染资源"><a href="#管理纹理贴图等渲染资源" class="headerlink" title="管理纹理贴图等渲染资源"></a>管理纹理贴图等渲染资源</h5><h5 id="在GLES和其他API之间同步渲染"><a href="#在GLES和其他API之间同步渲染" class="headerlink" title="在GLES和其他API之间同步渲染"></a>在GLES和其他API之间同步渲染</h5><h2 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h2><h3 id="创建连接EGLDisplay"><a href="#创建连接EGLDisplay" class="headerlink" title="创建连接EGLDisplay"></a>创建连接EGLDisplay</h3><h4 id="EGLDisplay-eglDisplay-EGLNativeDisplayType-displayId"><a href="#EGLDisplay-eglDisplay-EGLNativeDisplayType-displayId" class="headerlink" title="EGLDisplay eglDisplay(EGLNativeDisplayType displayId);"></a>EGLDisplay eglDisplay(EGLNativeDisplayType displayId);</h4><h4 id="参数默认窗口EGL-DEFAULT-DISPLAY"><a href="#参数默认窗口EGL-DEFAULT-DISPLAY" class="headerlink" title="参数默认窗口EGL_DEFAULT_DISPLAY"></a>参数默认窗口EGL_DEFAULT_DISPLAY</h4><h4 id="eglGetPlatformDisplayEXT"><a href="#eglGetPlatformDisplayEXT" class="headerlink" title="eglGetPlatformDisplayEXT"></a>eglGetPlatformDisplayEXT</h4><h5 id="EGLDisplay-eglGetPlatformDisplayEXT"><a href="#EGLDisplay-eglGetPlatformDisplayEXT" class="headerlink" title="EGLDisplay eglGetPlatformDisplayEXT("></a>EGLDisplay eglGetPlatformDisplayEXT(</h5><pre><code>EGLenum platform,
void *native_display,
const EGLint *attrib_list
</code></pre>
<p>);</p>
<h6 id="获取指定平台的EGL显示对象，更加灵活，支持X11-Wayland-GBM-Android平台"><a href="#获取指定平台的EGL显示对象，更加灵活，支持X11-Wayland-GBM-Android平台" class="headerlink" title="获取指定平台的EGL显示对象，更加灵活，支持X11\Wayland\GBM\Android平台"></a>获取指定平台的EGL显示对象，更加灵活，支持X11\Wayland\GBM\Android平台</h6><h5 id="attrib-list"><a href="#attrib-list" class="headerlink" title="attrib_list"></a>attrib_list</h5><h6 id="可选的属性列表，指定平台显示的一些附加配置。列表以-EGL-NONE-结束"><a href="#可选的属性列表，指定平台显示的一些附加配置。列表以-EGL-NONE-结束" class="headerlink" title="可选的属性列表，指定平台显示的一些附加配置。列表以 EGL_NONE 结束"></a>可选的属性列表，指定平台显示的一些附加配置。列表以 EGL_NONE 结束</h6><h3 id="egl初始化返回版本号"><a href="#egl初始化返回版本号" class="headerlink" title="egl初始化返回版本号"></a>egl初始化返回版本号</h3><h4 id="EGLBoolean-eglInitialize-EGLDisplay-display-创建步骤时返回的对象"><a href="#EGLBoolean-eglInitialize-EGLDisplay-display-创建步骤时返回的对象" class="headerlink" title="EGLBoolean eglInitialize(EGLDisplay display, &#x2F;&#x2F; 创建步骤时返回的对象"></a>EGLBoolean eglInitialize(EGLDisplay display, &#x2F;&#x2F; 创建步骤时返回的对象</h4><pre><code>                     EGLint *majorVersion, // 返回 EGL 主版本号
                     EGLint *minorVersion); // 返回 EGL 次版本号
</code></pre>
<h4 id="用上一步创建的display来初始化"><a href="#用上一步创建的display来初始化" class="headerlink" title="用上一步创建的display来初始化"></a>用上一步创建的display来初始化</h4><h3 id="确定可用的surface配置EGLConfig"><a href="#确定可用的surface配置EGLConfig" class="headerlink" title="确定可用的surface配置EGLConfig"></a>确定可用的surface配置EGLConfig</h3><h4 id="两种方法"><a href="#两种方法" class="headerlink" title="两种方法"></a>两种方法</h4><h5 id="eglGetConfigs查询配置，使用eglGetConfigAttrib找出最好选择"><a href="#eglGetConfigs查询配置，使用eglGetConfigAttrib找出最好选择" class="headerlink" title="eglGetConfigs查询配置，使用eglGetConfigAttrib找出最好选择"></a>eglGetConfigs查询配置，使用eglGetConfigAttrib找出最好选择</h5><h6 id="EGLBoolean-eglGetConfigs-EGLDisplay-display-指定显示的连接"><a href="#EGLBoolean-eglGetConfigs-EGLDisplay-display-指定显示的连接" class="headerlink" title="EGLBoolean eglGetConfigs(EGLDisplay display, &#x2F;&#x2F; 指定显示的连接"></a>EGLBoolean eglGetConfigs(EGLDisplay display, &#x2F;&#x2F; 指定显示的连接</h6><pre><code>                     EGLConfig *configs, // 指定 GLConfig 列表
                     EGLint maxReturnConfigs, // 最多返回的 GLConfig 数
                     EGLint *numConfigs); // 实际返回的 GLConfig 数
</code></pre>
<h6 id="EGLBoolean-eglGetConfigAttrib-EGLDisplay-display-指定显示的连接"><a href="#EGLBoolean-eglGetConfigAttrib-EGLDisplay-display-指定显示的连接" class="headerlink" title="EGLBoolean eglGetConfigAttrib(EGLDisplay display, &#x2F;&#x2F; 指定显示的连接"></a>EGLBoolean eglGetConfigAttrib(EGLDisplay display, &#x2F;&#x2F; 指定显示的连接</h6><pre><code>                          EGLConfig config, // 指定要查询的 GLConfig
                          EGLint attribute, // 返回特定属性
                          EGLint *value); // 返回值
</code></pre>
<h5 id="指定一组配置，使用eglChooseChofig让EGL推荐最佳配置"><a href="#指定一组配置，使用eglChooseChofig让EGL推荐最佳配置" class="headerlink" title="指定一组配置，使用eglChooseChofig让EGL推荐最佳配置"></a>指定一组配置，使用eglChooseChofig让EGL推荐最佳配置</h5><h6 id="EGLBoolean-eglChooseChofig-EGLDispay-display-指定显示的连接"><a href="#EGLBoolean-eglChooseChofig-EGLDispay-display-指定显示的连接" class="headerlink" title="EGLBoolean eglChooseChofig(EGLDispay display, &#x2F;&#x2F; 指定显示的连接"></a>EGLBoolean eglChooseChofig(EGLDispay display, &#x2F;&#x2F; 指定显示的连接</h6><pre><code>                       const EGLint *attribList, // 指定 configs 匹配的属性列表，可以为 NULL
                       EGLConfig *config,   // 调用成功，返会符合条件的 EGLConfig 列表
                       EGLint maxReturnConfigs, // 最多返回的符合条件的 GLConfig 数
                       ELGint *numConfigs );  // 实际返回的符合条件的 EGLConfig 数
</code></pre>
<h4 id="得到EGLConfig，包含渲染表面的所有信息，包括可用颜色、缓冲区等特性"><a href="#得到EGLConfig，包含渲染表面的所有信息，包括可用颜色、缓冲区等特性" class="headerlink" title="得到EGLConfig，包含渲染表面的所有信息，包括可用颜色、缓冲区等特性"></a>得到EGLConfig，包含渲染表面的所有信息，包括可用颜色、缓冲区等特性</h4><h3 id="创建渲染区域EGLSurface"><a href="#创建渲染区域EGLSurface" class="headerlink" title="创建渲染区域EGLSurface"></a>创建渲染区域EGLSurface</h3><h4 id="根据符合条件的EGLConfig，再创建渲染区域"><a href="#根据符合条件的EGLConfig，再创建渲染区域" class="headerlink" title="根据符合条件的EGLConfig，再创建渲染区域"></a>根据符合条件的EGLConfig，再创建渲染区域</h4><h5 id="EGLSurface-eglCreateWindowSurface-EGLDisplay-display-指定显示的连接"><a href="#EGLSurface-eglCreateWindowSurface-EGLDisplay-display-指定显示的连接" class="headerlink" title="EGLSurface eglCreateWindowSurface(EGLDisplay display, &#x2F;&#x2F; 指定显示的连接"></a>EGLSurface eglCreateWindowSurface(EGLDisplay display, &#x2F;&#x2F; 指定显示的连接</h5><pre><code>                              EGLConfig config, // 符合条件的 EGLConfig
                              EGLNatvieWindowType window, // 指定原生窗口
                              const EGLint *attribList); // 指定窗口属性列表，可为 NULL
</code></pre>
<h5 id="eglCreatePlatformWindowSurface"><a href="#eglCreatePlatformWindowSurface" class="headerlink" title="eglCreatePlatformWindowSurface"></a>eglCreatePlatformWindowSurface</h5><h4 id="返回EGLSurface"><a href="#返回EGLSurface" class="headerlink" title="返回EGLSurface"></a>返回EGLSurface</h4><h3 id="创建上下文EGLContext"><a href="#创建上下文EGLContext" class="headerlink" title="创建上下文EGLContext"></a>创建上下文EGLContext</h3><h4 id="创建可用的上下文"><a href="#创建可用的上下文" class="headerlink" title="创建可用的上下文"></a>创建可用的上下文</h4><h5 id="EGLContext-eglCreateContext-EGLDisplay-display-指定显示的连接"><a href="#EGLContext-eglCreateContext-EGLDisplay-display-指定显示的连接" class="headerlink" title="EGLContext eglCreateContext(EGLDisplay display, &#x2F;&#x2F; 指定显示的连接"></a>EGLContext eglCreateContext(EGLDisplay display, &#x2F;&#x2F; 指定显示的连接</h5><pre><code>                        EGLConfig config, // 前面选好的 EGLConfig
                        EGLContext shareContext, // 允许其它 EGLContext 共享数据，使用 EGL_NO_CONTEXT 表示不共享
                        const EGLint* attribList); // 指定操作的属性列表，只能接受一个属性 EGL_CONTEXT_CLIENT_VERSION
</code></pre>
<h5 id="第三个参数表示共享上下文"><a href="#第三个参数表示共享上下文" class="headerlink" title="第三个参数表示共享上下文"></a>第三个参数表示共享上下文</h5><h3 id="关联上下文，返回bool"><a href="#关联上下文，返回bool" class="headerlink" title="关联上下文，返回bool"></a>关联上下文，返回bool</h3><h4 id="指定某个EGLContext为当前上下文，关联特性的EGLConext和EGLSurface"><a href="#指定某个EGLContext为当前上下文，关联特性的EGLConext和EGLSurface" class="headerlink" title="指定某个EGLContext为当前上下文，关联特性的EGLConext和EGLSurface"></a>指定某个EGLContext为当前上下文，关联特性的EGLConext和EGLSurface</h4><h5 id="EGLBoolean-eglMakeCurrent-EGLDisplay-display-指定显示的连接"><a href="#EGLBoolean-eglMakeCurrent-EGLDisplay-display-指定显示的连接" class="headerlink" title="EGLBoolean eglMakeCurrent(EGLDisplay display, &#x2F;&#x2F; 指定显示的连接"></a>EGLBoolean eglMakeCurrent(EGLDisplay display, &#x2F;&#x2F; 指定显示的连接</h5><pre><code>                      EGLSurface draw, // EGL 绘图表面
                      EGLSurface read, // EGL 读取表面
                      EGLContext context); // 指定连接到该表面的上下文
</code></pre>
<h5 id="有两个EGLSurface，一个绘制Surface，一个读取Surface，有更高级用法"><a href="#有两个EGLSurface，一个绘制Surface，一个读取Surface，有更高级用法" class="headerlink" title="有两个EGLSurface，一个绘制Surface，一个读取Surface，有更高级用法"></a>有两个EGLSurface，一个绘制Surface，一个读取Surface，有更高级用法</h5><h3 id="开始API绘制"><a href="#开始API绘制" class="headerlink" title="开始API绘制"></a>开始API绘制</h3><h3 id="结束销毁"><a href="#结束销毁" class="headerlink" title="结束销毁"></a>结束销毁</h3><h2 id="常见数据结构"><a href="#常见数据结构" class="headerlink" title="常见数据结构"></a>常见数据结构</h2><h3 id="NativeDisplayType"><a href="#NativeDisplayType" class="headerlink" title="NativeDisplayType"></a>NativeDisplayType</h3><h4 id="Native系统显示类型"><a href="#Native系统显示类型" class="headerlink" title="Native系统显示类型"></a>Native系统显示类型</h4><h3 id="NativeWindowType"><a href="#NativeWindowType" class="headerlink" title="NativeWindowType"></a>NativeWindowType</h3><h4 id="Native系统窗口缓存类型"><a href="#Native系统窗口缓存类型" class="headerlink" title="Native系统窗口缓存类型"></a>Native系统窗口缓存类型</h4><h3 id="NativePixmapType"><a href="#NativePixmapType" class="headerlink" title="NativePixmapType"></a>NativePixmapType</h3><h4 id="Native系统Framebuffer"><a href="#Native系统Framebuffer" class="headerlink" title="Native系统Framebuffer"></a>Native系统Framebuffer</h4><h2 id="少见的egl接口"><a href="#少见的egl接口" class="headerlink" title="少见的egl接口"></a>少见的egl接口</h2><h3 id="子主题-3"><a href="#子主题-3" class="headerlink" title="子主题"></a>子主题</h3>]]></content>
  </entry>
</search>
